[["introduction-to-r.html", "Introduction to R 1 Introduction To R 1.1 Agenda", " Introduction to R James Simkins 2020-12-02 1 Introduction To R Hello! Welcome to Tech Trainings - From Excel to R. We’re here to enhance the productivity of your business by ditching Excel and employing R. Our tutorials are focused and designed for employees currently working. R is currently ranked as the 7th most popular language in the world - and with good reason! We’ll dive into why R is ranked so high and how it can benefit you and your business. This intro to R course is designed to teach R to businesses and employees who frequently use Excel for day-to-day operations. Few businesses around the world leverage the amazing features of R and we’re here to teach these skills. To put it bluntly, R saves you and your employees a ton of time. We’ve seen users cut down daily 2-3 hour tasks in Excel into 2-3 minutes after some basic introduction to R. In this case, R saved this individual employee 750 hours per year - allowing employee time to be used towards more creative problem-solving endeavors. This is a concentrated, fast-paced course designed to improve business efficiency, cut down tedious tasks, and increase the creative time spent by employees. Most online R tutorials are far too broad and can leave a student frustrated at the vast abilities of R. R can be used to accomplish a great deal, but instead of showing off what R can do, we discuss and teach select skills that can be used to improve day-to-day business efficiency immediately. We’re not here to waste your time and overwhelm our students like other R workshops. This concentrated course follows a design of specific problem solving. We present common business practices often handled using Excel and show an employee can use R to accomplish the same task at a faster pace. The workshop is split into 5 days with assignments due each day. This course was developed by James Simkins who has developed and taught multiple programming courses at the University of Delaware. 1.1 Agenda This course is designed to be a 5 day course intended to provide students with a strong foundation in R concepts and fundamentals. The intended time per day is 2-3 hours. Day Focus 1 R/RStudio Installation &amp; Overview 2 Functions and Classes 3 DataFrames, Indexing, and For Loops 4 Dataset Ingest and Plotting 5 Final Project: World Cup Data "],["getting-started-with-r.html", "2 Getting Started with R 2.1 Why is R so popular? 2.2 Installing R 2.3 Installing Rstudio 2.4 Video Examples 2.5 Getting familiar with RStudio 2.6 Open RStudio 2.7 R Studio Layout 2.8 Writing a script in R", " 2 Getting Started with R 2.1 Why is R so popular? R is an open-source programming language used for data science, statistics, and data visualization. R is currently ranked as the 7th most popular language in the world. Since R is open-source, anyone can contribute to or use R packages that contain pre-built functions/operations. This greatly accelerates our ability to share and collaborate. The purpose of this workshop is to teach working professionals how to use R for tasks they’d normally use Excel for. Excel is a powerful tool and is great for a variety of uses, but when it comes to crunching data, R will greatly improve the speed at which these tasks can be done. Furthermore, with R, mundane &amp; tedious tasks can be automated. When you write a script in R for a recurring task such as calculating a monthly budget, all one needs to do each month is provide the routine with a new dataset to crunch the numbers. Below are examples of why we use R. Attribute Reason Speed R is FAST. It can number crunch magnitudes faster than Microsoft Excel, for example. Capacity R can handle millions of data records. Large datasets that crash in Microsoft Excel won’t crash in R. Risk Reduction After writing a single R Script, the process of your data science routine is auditable and reproducible within milliseconds. We can write 1 script and make alterations as we see fit. We don’t have to replicate a process of pointing and clicking in Microsoft Excel or ArcGIS. For example, if you are working with a dataset that multiple people are using, you can load this dataset in R and perform the tasks that you need without making any changes to the original dataset. Visualizations R is capable to create high quality visualizations and also has the capacity to create interactive visualizations that can easiliy be shared. Plots or images can easily be exported to PNG, JPEG, or even web-based interactive dashboards that can be hosted on a webpage Collaboration R script sharing is safe and easy. As mentioned above, a team using the same data input file but performing different tasks on it can do so without editing the data input file for everyone else. Data output can also be shared without the concern of a colleague editing the file output. RStudio connect or Github are also popular free track all changes that take place between R script files. Price R is completely free! Yes…every bit of it! 2.2 Installing R Navigate to the R website: https://cloud.r-project.org/ Click Download for your Operating System (Windows, Mac OSx, or Linux - if you don’t have a MacBook, then you’re using Windows most likely) Click the most recent R version to download. Install the downloaded application as you would with any other application on your computer. 2.3 Installing Rstudio While R is the language, RStudio is the application we use to run R. Technically speaking, RStudio is an integrated development environment for R. RStudio makes coding in R easier by highlighting syntax, autocompleting symbols and names, and visualizing our R environment. These aspects are explained in further detail in the [R Coding Fundamentals] section. For now, let’s download RStudio. Navigate to the RStudio Website: http://www.rstudio.com/download Click Download under RStudio Desktop Free This website detects your operating system, allowing you to just click download again. Note that if it doesn’t automatically detect just select the download next to your operating system below this Note that you may be asked to install command line developer tools if you’re using a Mac - select Yes. Install the downloaded application as you normally would on your computer. 2.4 Video Examples If you want to watch a step-by-step tutorial on how to install R for Mac or Windows, you can watch these videos courtest of Dr. Roger Peng Installing R on Windows Installing R on the Mac Installing RStudio 2.5 Getting familiar with RStudio By now you’ve downloaded R and RStudio and you’re probably wondering, why do I need to download both? R is that programming language that is running on your computer. RStudio is what we call an Indegrated Development Environment (IDE) - this is a technical term for a pretty application that’s all dressed up on the surface but underneath is really crunching some numbers (using R) at serious speeds. RStudio is the application we’ll be using. Let’s open RStudio and get familiar with it. 2.6 Open RStudio Navigate to your applications folder on your computer. Launch RStudio. When you open it for the first time, you should see this. This is RStudio. When you open it for the first time, we’ll need to open a new RScript to begin coding. Open new R Script To open a new R Script, we select the blankpage with green plus icon and select R Script from the menu. This opens up the new R script and we can begin coding in R. Now that we have the R Script open, you’ll notice 4 quadrants. Let’s run through what those quadrants are. 2.7 R Studio Layout Now let’s describe what’s going on here in a little more detail. R Script - This is your canvas. This is where we write and edit our code. A lot of trial and error goes on here. R Console - This is where you run your code. When we talk about running code, we mean we’re telling R to execute the code we’ve written in the R Script. R Console is the place inside RStudio where we are using the R programming language. Variable Environment - This area keeps track of your variables, data tables, filenames, etc. Anything that you run in R that has a name will be stored here. Imagine the Variable Environment to be your closet - every time you make/buy a new sweater, the sweater goes in the closet. We can select data tables to view from this list here. Files/Plots/Help - In this quadrant, we can toggle through files on our computer (we can view where your files are stored), view plots/visualizations that we’re creating in R (whenever you create a plot in R it is output here first), search for help and descriptions of R functions (there’s descriptions on every function you’ll use in R - they can all be loaded here in the help tab), and more. 2.8 Writing a script in R An R script (also referred to as “code”) is the file we create that uses the R programming language to accomplish a task. R scripts are saved R routines that we can load up at any time to perform an action with R. Every R script is written in the R Script area but executed below in the console area. 2.8.1 Input &amp; Evaluation In the R Script area, we write code. Whenever we want to assign a variable, we do so using the assignment operator. The &lt;- symbol is the assignment operator. We can also use = which is a bit more intuitive. It is alright to interchange these when assigning variables. val &lt;- 1 number = 5 my_text = &quot;hello&quot; my_math &lt;- 9*2 + 5 - 10 We write the above code in the R script area. When we are finished writing, we need to test the code to see if it works. When we test the code, we’re running the code (also referred to as executing the code). R code is executed in the console area. In order to run our R code, we have a few options to do so… 2.8.2 Running Code The following are ways we can run our R code. Highlight the code we wish to run and click ctrl + enter (Windows) or cmd + enter (Mac OSX) We can “send” our code in the R Script to the R Console using the Run Button (located in the top right corner of the R Script area). Notice there are various options for what lines to run (selected lines, next chunk, current chunk, etc.) We can copy the lines we wish to run from the R Script area and paste them into the R Console. Each of these methods are useful for running R code, although perhaps the easiest method is #1. Let’s run the code we wrote above… val &lt;- 1 number = 7.779 my_text = &quot;hello&quot; my_math &lt;- 9 - 2 + 5 - 10 After we run these lines of code successfully, these values are now saved as variables in the R Global Environment area (top right quadrant). After running, we should see a blinking cursor next to a &gt; symbol in the console. This means we successfully ran this code and the R console is ready for more. What if we don’t see this? 2.8.3 Errors When we code in any programming language, we are practicing trial and error. The reality is that most of the code we write will have errors in it and that’s ok! Even experienced programmers have plenty of errors, or bugs, in their code. One can measure their programming ability through how quickly one can diagnose a bug and fix it. Let’s practice diagnosing and fixing some errors. x -&lt; 55 When we run the line above, the console returns with a message that says: Error: unexpected ‘&lt;’ in “x -&lt;”. What did we do wrong? When we assign a variable, the assignment operator must be either = or &lt;-. Notice that we coded our assignment operator incorrectly like so; -&lt;. We simply need to edit this like so… x &lt;- 55 Often our errors come down to something as simple as this. Let’s look at another example… val &lt;- 1 number = 7.779 my_text = hello&quot;&quot; my_math &lt;- 9 - 2 + 5 - 10 Error: unexpected string constant in &quot;my_text = hello&quot;&quot;&quot;. Any character strings (aka text) that we write in R must be enclosed in quotations. Our text message, hello, is not enclosed within these quotation marks. Simply enclose hello between two quotation marks and re-run the line. As a quick aside, notice that R still successfully ran the other lines of code - this is because R is an iterative language. val &lt;- 1 number = 7.779 my_text = &quot;hello&quot; my_math &lt;- 9 - 2 + 5 - 10 2.8.4 Objects &amp; Variables As mentioned above, when we execute the code above the objects/variables are stored locally in R and are displayed in the global environment in the top right quadrant. These objects/variables can now be called at any point. For example, if we head down to the console and type; print(val) R returns 1, as this is the value we declared for the val variable/object above. We just introduced something new - the print() function. We’ll get into functions later, but the print function is pretty intuitive - it just prints out values that are stored in R. What happens if we print my_math ? print(my_math) R solved the equation we wrote above for us. Now, the my_math variable/object has a stored value of 2. From this point forward, we will use the term variable/object interchangeably as they mean the same thing. 2.8.5 Variable Names There are rules associated with naming a variable. Names are Case Sensitive. No spaces allowed within the name (i.e. NO naming like so a 1 = 11) Variable names cannot begin with a number (i.e. NO naming like so 1a = 11) # The following are all acceptable variable names a = 1 A = 55 # We can use underscores _ and periods . within our names as long as there are no spaces a1 &lt;- 11 a_1 &lt;- 11 a.1 &lt;- 11 2.8.6 Commenting &amp; Note Taking Commenting is the R term for note taking within our code. We can describe what is occurring within our code at any line using the comment symbol #. R will ignore anything on a line of code after the comment symbol #. Run the following… # set val variable equal to 1 val &lt;- 1 # see how R doesn&#39;t run anything on the line beyond the # symbol num # = 180 Error: object 'num' not found. We placed the # symbol before we declared the num variable. Since R doesn’t have a value stored for num and since we ignored our definition, R will return an error. # set val variable equal to 1 val &lt;- 1 # see how R doesn&#39;t run anything on the line beyond the # symbol num = 180 # much better Commenting is always a good idea for future users of the code (including yourself!). It is not necessary to comment/take notes on each line, but it is useful for broader chunks of code as we’ll see when we write longer scripts. # Print out num print(num) ## [1] 180 The output above beginning with the ## [1] is output from the tutorials R console. Technically, it is the first line (hence the [1]) of R console output. This is RStudio’s way of discerning between written code and console output. You will see this more frequently as we go further in this tutorial and your output should look identical. 2.8.7 Saving this R script When we are finished using R for a day, we can save multiple things. First and foremost, it is always a good idea to save your R script. When we save an R script, we can re-load it and re-run it at any point in the future. When we write more advanced code, we might need to run an R script once a month when a new batch of data comes in. We can reload the R script, plug in the new dataset, and click run - it’s as simple as that! To save an R script… Click File &gt; Save Choose a folder on your computer to save to. Create a unique file name with the extension .R (such as my_first_script.R) Click Save Note that it is always a good idea to use underscores (_) or dashes (-) instead of spaces in a file name. This is because computing systems have trouble with spaces from time to time. When you’re ready to close RStudio… Make sure all scripts you’ve edited are saved. Click x in the upper corner of your RStudio You will be prompted with the question of Save workspace image to ~/.RData ?. What this means is, do you want to save your global environment with all the variables currently in there? This can save time in the future if you don’t wish to re-run code. Most of the time, it’s not a big deal to re-run code and start with a fresh RStudio workspace. Typically we select No and then are able to close RStudio. This concludes Day 1 of our Introduction to R Course. Please complete the Checkpoint Assignments "],["functions-classes.html", "3 Functions &amp; Classes 3.1 Packages and Functions 3.2 Arguments 3.3 R Objects 3.4 Lists 3.5 Factors 3.6 Matrices", " 3 Functions &amp; Classes In R, a package is a collection of functions. Imagine a package as a toolbox and functions as the tools within the toolbox. If we want to load the wrenches toolbox, we can load it like so - library(wrenches). Then, we can use different wrenches from that toolbox like - rachet_wrench(), small_wrench(), big_wrench(). These would be called functions. Functions are pre-written chunks of code that perform an action in R. When we use something like a rachet_wrench(), we’ll need to select a socket to put on. In this example, the socket we put on the rachet_wrench is called an argument. Arguments are interchangeable parameters that are needed to run the function. 3.1 Packages and Functions In R, a base package is automatically loaded in for you. Most of the time, we will need to install packages as RStudio only comes with a few pre-installed packages. When we do need to install packages, we only need to install it one time for it to be downloaded to our machine. All packages in R are FREE. Now, let’s check back in on our pre-installed packages. One of these pre-installed packages is called base. Within the base package, we can find common functions such as mean(), min(), max(),print(), seq(), etc. Even though it’s redundant, let’s load the base package. Next, let’s write create a variable named my_val, and print out the value using the print() function. library(base) my_val = 77 print(my_val) ## [1] 77 The base package was opened to use the print function which had an argument of my_val. After you load in an argument in an R session, you do not need to reload it again. Now let’s look at an example where we create a sequence of numbers using the seq() function. library(base) my_seq = seq(from = 10, to = 20, by = 1) print(my_seq) ## [1] 10 11 12 13 14 15 16 17 18 19 20 The base package was opened to use the seq function which had 3 arguments; from, to, and by. 3.2 Arguments Arguments must be declared using the = operator and are always separated by a comma. In the last example, we used the seq() function which had arguments of from, to, and by. How do we know the argument names? help(seq) The help() function is automatically loaded for you and has detailed information and examples of functions you may want to use. Notice that we have arguments from, to, by, length.out, and along.with. These arguments are pre-definded, meaning if you don’t declare the values for the arguments, the function will automatically have arguments declared for you. Lets see what happens if we don’t declare any arguments for this function… seq() ## [1] 1 Now try the same with the print() function print() Error in print.default() : argument &quot;x&quot; is missing, with no default. There is no pre-defined value of x for print() to use. But, wait a second, when we coded print(my_seq), we didn’t declare the x argument?. That’s right, you don’t have to declare the arguments by name if you follow the prescribed order of the arguments in the function. For example, the prescribed order of the seq() function is from, to, and by. Let’s remove our argument names and see what happens… my_seq = seq(10,20,1) print(my_seq) ## [1] 10 11 12 13 14 15 16 17 18 19 20 The result is the same because we kept the same order. This notation is sometimes called shorthand argument declaration. Pay attention to the commas as they are absolutely necessary for separating the arguments. Now, let’s see what happens if we have the same from, to and by values but formally declare them out of order. my_seq = seq(by = 1, from = 10, to = 20) print(my_seq) ## [1] 10 11 12 13 14 15 16 17 18 19 20 Once again, the result is the same. Although we can get away with shorthand argument declaration, it’s always a good idea to formally declare them for future users of the code (including yourself!). 3.3 R Objects R has five basic classes of objects: character numeric (real numbers) integer logical (True/False) complex Use the class() function (from the base package, so we don’t need to load anything) to figure out what class an object/variable is. Let’s take a look at the example above. val &lt;- 1 class(val) ## [1] &quot;numeric&quot; a = 7.779 class(a) ## [1] &quot;numeric&quot; my_text = &quot;hello&quot; class(my_text) ## [1] &quot;character&quot; R recognizes each of these objects as different classes. 3.3.1 Characters Characters are text that are declared within quotations (or apostrophes). They can be single phrases OR can be a collection of words. When we have multiple words within quotations we refer to this as a character string. my_text = &#39;hello&#39; snacks = &quot;Chips and Pretzels are my favorite snacks&quot; class(snacks) ## [1] &quot;character&quot; my_name = &#39;Winston Churchill&#39; class(snacks) ## [1] &quot;character&quot; 3.3.2 Numeric Often times our data contains numbers that carry digits after a decimal place. In R, these are referred to as numeric values. a = 7.71 b = 123451.890803843 If we have a larger dataset, we may have more than 1 value per object. Objects can also represent a vector of numeric values. Vectors are a collection of values of the same class. In other words, it can be a collection of numeric values, a collection of character strings, etc. We can create vectors using the concatenate (aka combine) function. Let’s use the combine function c() to create a vector of numeric values. num_vect = c(7.71, 8.65, 9.34, 10.89, 19.55) print(num_vect) ## [1] 7.71 8.65 9.34 10.89 19.55 class(num_vect) ## [1] &quot;numeric&quot; Notice that num_vect represents this collection, yet the class of the collection is numeric. As stated above, vectors must be a collection of the same class. 3.3.3 Integers If we specify a number value in R, it is automatically classified as a numeric even if that value looks like an integer to us. In order to create an integer, we can use the as.integer() function. i = as.integer(9) class(i) ## [1] &quot;integer&quot; We can use the as.integer() function to convert numeric values to integer values. x = 3.14 i = as.integer(x) print(i) ## [1] 3 class(i) ## [1] &quot;integer&quot; There are also similar functions for the other classes such as as.character() and as.numeric(). 3.3.4 Logicals A logical is a special value in R that details a comparison. Some logical values you may use include TRUE, FALSE, &amp; (and), | (or), and ! (negate). b = TRUE y = c(TRUE, FALSE) class(y) ## [1] &quot;logical&quot; The latter logical values - &amp; (and), | (or), and ! (negate) - are usually found in for loops which we’ll cover later on. Here’s a brief example of how they work. a = TRUE b = FALSE a &amp; b ## [1] FALSE a | b ## [1] TRUE !a ## [1] FALSE 3.3.5 Complex values We won’t be using many complex values in R, but R does support them. Complex values use the letter i immediately following a number. x &lt;- c(1+2i, 3+8i) # complex class(x) ## [1] &quot;complex&quot; 3.4 Lists Lists are a special type of vector that can contain elements of different classes. Lists are a very important data type in R and you should get to know them well. Lists, in combination with the various “apply” functions discussed later, make for a powerful combination. Lists can be explicitly created using the list() function, which takes an arbitrary number of arguments. x &lt;- list(1, &quot;a&quot;, TRUE, 7.65334) x ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] 7.65334 3.5 Factors Factors are used to represent categorical data and can be unordered or ordered. One can think of a factor as an integer vector where each integer has a label. Using factors with labels is better than using integers because factors are self-describing. Having a variable that has values “Male” and “Female” is better than a variable that has values 1 and 2. Factor objects can be created with the factor() function. x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: no yes table(x) ## x ## no yes ## 2 3 # See the underlying representation of factor unclass(x) ## [1] 2 2 1 2 1 ## attr(,&quot;levels&quot;) ## [1] &quot;no&quot; &quot;yes&quot; Often factors will be automatically created for you when you read a dataset in using a function like read.table(). Those functions often default to creating factors when they encounter data that look like characters or strings. The order of the levels of a factor can be set using the levels argument to factor(). x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;)) x ## Levels are put in alphabetical order ## [1] yes yes no yes no ## Levels: no yes x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: yes no 3.6 Matrices A matrix is a collection of data elements arranged in a two-dimensional rectangular layout. As you learn more about R, you’ll find that Matrices are very popular. A matrix is one way to store a table of data, such as an excel spreadsheet. For example, let’s create a matrix of fruits consumed by a family for each day of the week. We have apples and oranges as our fruits and 7 days in the week. A matrix might look like this. matrix of fruits consumed by day might look like this. apples = c(2, 4, 3, 1, 5, 7, 3) # apples consumed each day of the week oranges = c(4, 3, 5, 1, 2, 3, 2) # oranges consumed each day of the week fruits = matrix( data=c(apples, oranges), # the data elements nrow=7, # number of rows ncol=2, # number of columns byrow = FALSE) # fill matrix by columns instead of rows Notice that the matrix function takes multiple arguments including data, nrow, ncol, and byrow. The byrow argument takes a logical value. This is a new way to code as we are placing each argument on it’s own line so we can detail what’s happening with the # symbol. R doesn’t care what happens on each line as long as arguments are specified, separated by commas, and enclosed by the proper parentheses. Let’s take a look at our fruits matrix… fruits ## [,1] [,2] ## [1,] 2 4 ## [2,] 4 3 ## [3,] 3 5 ## [4,] 1 1 ## [5,] 5 2 ## [6,] 7 3 ## [7,] 3 2 Notice that we didn’t use the print() function above, we just keyed in fruits. This is referred to as auto-printing. We don’t actually need to use the print() function any longer as we can use the auto-print help here instead. We have 2 columns which are comprised of the apples and oranges consumed each day, respectively. We have 7 rows for each day of the week. If we want to, we can rename our values in fruits to reflect our row and column names using rownames() and colnames() functions respectively. weekday_vector = c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;) fruit_vector = c(&quot;Apples&quot;, &quot;Oranges&quot;) rownames(fruits) &lt;- weekday_vector colnames(fruits) &lt;- fruit_vector fruits ## Apples Oranges ## Mon 2 4 ## Tue 4 3 ## Wed 3 5 ## Thu 1 1 ## Fri 5 2 ## Sat 7 3 ## Sun 3 2 Our rows and columns have been renamed based on the weekday_vector and fruit_vector that we created above using the combine function c(). Let’s double check the class here… class(fruits) ## [1] &quot;matrix&quot; &quot;array&quot; fruits is indeed a matrix class. It is also an array class. While a matrix is a 2 dimensional set of data like one with rows and columns, an array is a multi-dimensional dataset. An array can have unlimited dimensions. Technically speaking, a matrix is a 2 dimensional array which is why fruits is a matrix class and an array class. More often than not, we’ll stick with matrices and dataframes (introduced next) as opposed to arrays. An important note is that like vectors, the data (apples and orange vectors) within a matrix must be of the same class. For example, both the apples and oranges vectors are of a numeric class which allowed the matrix to be built without any errors. "],["dataframes-indexing-and-for-loops.html", "4 DataFrames, Indexing, and For Loops 4.1 Data Frames 4.2 Indexing Data Frames 4.3 For Loops", " 4 DataFrames, Indexing, and For Loops 4.1 Data Frames Data frames are used to store tabular data in R. They are an important type of object in R and are used in a variety of applications. We’ll be working with many dataframes throughout these tutorials. Data frames are represented as a special type of list where every element of the list must have the same length. Each element of the list can be thought of as a column and the length of each element of the list is the number of rows. Data frames are similar to matrices but one key distinction is that data frames can store different classes of objects in each column. As a reminder, each element of a matrix must be of the same class (e.g. all integers or all numeric). In addition to column names, indicating the names of the variables or predictors, data frames have a special attribute called row.names which indicate information about each row of the data frame. Data frames are usually created by reading in a dataset using the read.table() or read.csv(). However, data frames can also be created explicitly with the data.frame() function or they can be coerced from other types of objects like lists. Let’s continue to use our fruits example but this time create a dataframe using the data.frame() function from the base package. apples = c(2, 1, 3, 0, 5, 7, 3) # apples consumed each day of the week oranges = c(4, 1, 5, 0, 2, 3, 2) # oranges consumed each day of the week fruits_df &lt;- data.frame(Apples = apples, Oranges = oranges) fruits_df ## Apples Oranges ## 1 2 4 ## 2 1 1 ## 3 3 5 ## 4 0 0 ## 5 5 2 ## 6 7 3 ## 7 3 2 Our Column names are reflected by our specification within the data.frame() function. Let’s adjust the rownames like we did before. weekday_vector = c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;) rownames(fruits_df) = weekday_vector fruits_df ## Apples Oranges ## Mon 2 4 ## Tue 1 1 ## Wed 3 5 ## Thu 0 0 ## Fri 5 2 ## Sat 7 3 ## Sun 3 2 At this point, fruits_df looks identical to our fruits matrix from the previous section. What’s the class? class(fruits_df) ## [1] &quot;data.frame&quot; Remember, the advantage of using a data.frame in R is that it can contain elements of different classes. For example, we could add an additional column to our fruits_df with a logical description of whether soccer practice took place. apples = c(2, 1, 3, 0, 5, 7, 3) # apples consumed each day of the week oranges = c(4, 1, 5, 0, 2, 3, 2) # oranges consumed each day of the week soccer_practice = c(FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE ) fruits_df &lt;- data.frame(Apples = apples, Oranges = oranges, Soccer_Practice = soccer_practice) weekday_vector = c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;) rownames(fruits_df) = weekday_vector fruits_df ## Apples Oranges Soccer_Practice ## Mon 2 4 FALSE ## Tue 1 1 TRUE ## Wed 3 5 FALSE ## Thu 0 0 TRUE ## Fri 5 2 FALSE ## Sat 7 3 FALSE ## Sun 3 2 FALSE Data Frames are a powerful class in R. We can actually click on our fruits_df data.frame in the global environment and visualize it. This is only recommended if you are dealing with a smaller data frame as larger data frames can freeze your computer if you visualize the table. 4.2 Indexing Data Frames Indexing is a skill necessary for shrinking a dataset or extracting specific information. Through indexing, we can isolate a column, a row, or even replace data. For example, let’s say we only want to handle the Apples column within the fruits_df dataframe. This can be done via indexing like so… fruits_df[&quot;Apples&quot;] ## Apples ## Mon 2 ## Tue 1 ## Wed 3 ## Thu 0 ## Fri 5 ## Sat 7 ## Sun 3 Using this notation of calling the data.frame, using square brackets [] with the appropriate column name inside (&quot;Apples&quot;), we were able to isolate only the Apples column within this dataframe.Let’s say, for example, that we only want to use the data within that column and don’t care for the data.frame of just that column. fruits_df[,&quot;Apples&quot;] ## [1] 2 1 3 0 5 7 3 What’s the difference? Notice the comma preceding the &quot;Apples&quot; name. Data is stored as data[row, column] in R. Therefore, when we use code like fruits_df[,&quot;Apples&quot;], we’re telling R that we want to grab all rows of data and the &quot;Apples&quot; column. The same can be performed using numeric operation. fruits_df[,1] ## [1] 2 1 3 0 5 7 3 We named our columns within our fruits_df Data Frame and that’s why we can use the column names to subset data. However, these rows and columns also have numbers associated with them. When we code fruits_df[,1], we’re telling R that we want all rows and the first column. When we want all rows or columns, simply leave the space blank before/after a comma. We can subset even further by selecting the specific row that we want. fruits_df[5,1] ## [1] 5 Here we grab the fruits_df data point from the 5th row and 1st column within the fruits_df. This is indexing/subsetting! We’re taking a piece of our dataframe that we select using the square brackets [] . An important note is that this is the same way matrixes can be indexed/subset. One advantage that data frames has over matrices aside from the mixed class of elements it can hold is the use of the $ operator. fruits_df$Apples ## [1] 2 1 3 0 5 7 3 When the $ operator is used immediately following a data frame call, we can access the vector of data specified within that column of our dataframe. When we return a vector of data like we can with fruits_df$Apples, we’ve subsetted that specific column. Therefore, we no longer have the option to specify using data[row,column] since we only have 1 column. Instead, we can subset to only a specific row within that column. fruits_df$Apples[5] ## [1] 5 This returns the element within the 5th row of the Apples column of the fruits_df dataframe. Indexing will be very useful for dataframes and other classes of data moving forward. 4.3 For Loops For loops &amp; conditional statements are a key skill in programming. They allow you to automate a process and decrease the amount of manual work performed. They remove tedious procedures. For loops often contain the use of arithmetic and conditonal operators. Operator Name Example Definition arithmetic operators +,-,*,/,^ Math operators used for addition, subtraction, multiplication, division, exponent, respectively. comparison operators ==, &lt;, &gt;, &lt;=, &gt;=, != Is equal to, less than, greater than, less than or equal to, greater than or equal to, is NOT equal to, respectively and/or operators &amp;, | AND, OR We’ve already discussed and even used some of these operators but they commonly occur within a for loop. The general structure of a for loop looks like… for (condition){ perform action } Let’s loop through a sequence of numbers. # Generate sequence of numbers from 1 to 10 using the seq() function numbersList = seq(from=1,to=10,by=1) # print the value of i for (i in numbersList){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Here, our condition is to loop through each i value within numbersList. The value is i changes with each iteration of the loop. The action we perform is printing i. i is arbitrary and can be called whatever temporary variable name we want. For example, let’s use asdf instead of i. # Generate sequence of numbers from 1 to 10 using the seq() function numbersList = seq(from=1,to=10,by=1) # print the value of i for (asdf in numbersList){ print(asdf) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 The result is the same. The condition is always initiated by a for call and then placed inside parentheses. The action we perform is always follows the condition and is placed inside curly brackets. Always remember, for(condition){perform action} Now let’s build of the above example and use some of our conditional. # Generate sequence of numbers from 1 to 10 using the seq() function numbersList = seq(from=1,to=10,by=1) # print i if the number is greater than 4 for (i in numbersList){ if (i &gt; 4){ print(i) } } ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 This is referred to as a nested loop because we have an if statement within a for loop. The general structure is for(condition){if(condition){perform action}}. In this example, we only print i if i is greater than 4. What happens if we change the numbersList? # Generate sequence of numbers from 70 to 80 using the seq() function numbersList = seq(from=70,to=80,by=1) # print i for (i in numbersList){ print(i) } ## [1] 70 ## [1] 71 ## [1] 72 ## [1] 73 ## [1] 74 ## [1] 75 ## [1] 76 ## [1] 77 ## [1] 78 ## [1] 79 ## [1] 80 Now, let’s say there’s a scenario where we care more about the total number of values within numbersList as opposed to the actual numbersList value. We can use 1:length(numbersList) to accomplish this. # Generate sequence of numbers from 70 to 80 using the seq() function numbersList = seq(from=70,to=80,by=1) length(numbersList) ## [1] 11 # print i for (i in 1:length(numbersList)){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ## [1] 11 Notice that the length of numbersList is 11 and that i is ranging from values of 1 to 11. The colon operator : acts as a sequence maker that automatically spans by 1 between two values. In the next scenario, let’s loop from 1 to the length of numbersList and then if our loop variable i is equal to 7, let’s multiple the 7th value of the numbersList by 8 and store it as temNumber. # Generate sequence of numbers from 1 to 10 using the seq() function numbersList = seq(from=70,to=80,by=1) print(numbersList[7]) ## [1] 76 # multiply numbersList[i] by 8 if i is equal to 7 for (i in 1:length(numbersList)){ if (i == 7){ temNumber = numbersList[i] * 8 } } print(i) ## [1] 11 print(temNumber) ## [1] 608 The first condition specifies that to loop through each i between 1 and the length of numbersList. With our condition specified like this, are still looping from 1 to 10. The second condition specifies that if i is exactly equal to 7, multiply with 7th value in numbersList (aka numbersList[7]) by 8 and store it as temNumber. Afterwards, we print out i and temNumber. We notice that i is equal to 11, the length of our numbersList. Meanwhile, temNumber is equal to 608, since i was exactly equal to 7 and thus 76 (numbersList[7]) was multiplied by 8. For loops are very customizable as we can see above. Let’s explore one more example and this time use our fruit_df data frame to answer a question. How many Apples were consumed on days where there was no soccer practice? for (d in 1:length(fruits_df$Apples)){ if (fruits_df$Soccer_Practice[d] == FALSE){ print(fruits_df$Apples[d]) } } ## [1] 2 ## [1] 3 ## [1] 5 ## [1] 7 ## [1] 3 This lists all of the apples consumed on days where there was no soccer practice. Now, we could manually add up these values to find the total number of apples consumed. However, we’re here to learn how R can crunch that number for us. In order to crunch that number, we’ll need to introduce a new function called append(). append() literally appends values to the end of an existing vector. For example… # create a new vector called numbers_vec numbers_vec = c(19) print(numbers_vec) ## [1] 19 # use the append function to add 24 to the end of our vector numbers_vec = append(x = numbers_vec, values = 24) print(numbers_vec) ## [1] 19 24 Notice that we are overwriting numbers_vec. Now, our numbers_vec vector includes the original 19 and 24. Now that we know how to use this, we can bring this into our for loop and create a new vector that only contains apples consumed on days where there was no soccer practice. # create new_apples blank vector new_apples = c() for (d in 1:length(fruits_df$Apples)){ if (fruits_df$Soccer_Practice[d] == FALSE){ new_apples = append(x = new_apples, fruits_df$Apples[d]) } } # print the new_apples values new_apples ## [1] 2 3 5 7 3 # sum the total number of apples consumed when there was no soccer practice sum(new_apples) ## [1] 20 There were 20 apples consumed on days where there was no soccer practice. "],["dataset-ingest-and-plotting.html", "5 Dataset Ingest and Plotting 5.1 Installing a Package 5.2 Reading Data 5.3 Paths 5.4 Plotting the Data", " 5 Dataset Ingest and Plotting Reading data into R is a regular practice. R can ingest almost any type of file including CSV, Excel, Binary, XML, JSON, and many more. Today, we’re going to read in a Microsoft Excel file into R. This file contains data on best-selling books from Amazon between 2009 and 2019. Before we begin, we will need to download the amazon_bestsellers.xlxs file from the course datasets folder. 5.1 Installing a Package So far, we’ve only been using functions that are part of the base package and are automatically loaded into each session by RStudio. There are over 10,000 R packages available for download from R’s package repository. All of these packages are free and contain pre-written functions for just about any computing purpose. Today, we’re going to use the readxl package. This package helps us read Microsoft Excel files in R. Let’s load in this package. library(readxl) Error in library(readxl) : there is no package called ‘readxl’. This package is not currently installed. We can install the function now using the install.packages() function from the pre-loaded base package. install.packages(&quot;readxl&quot;) You may need to select a CRAN Mirror before installing. CRAN stands for Comprehensive R Archive Network and it is a repository for R packages that is a replica of the primary R package database. You can select any of these mirrors, but it is recommended that you choose a mirror located in the United States if RStudio asks you to choose one. Only use the install.packages() function in the console. Why? We only need to install a package once. After the package is installed, we will need to load the package into each R session but we will not need to install it again. After readxl is installed correctly, you’ll see a message that looks like this; The downloaded binary packages are in /var/folders/6m/1b7gn_m93g9380p1jxvm2_700000gr/T//Rtmpcuw03I/downloaded_packages This is the location on your computer where the package and all it’s functions are stored. We don’t need to worry about the location as R handles this information for us. We also don’t need to worry about packages taking up significant space on our hard drives. R packages are small in size. Now that readxl is installed, we can load it in via the library() function like we did above. This time, however, it should load in without any errors. library(readxl) Wonderful, now we can use functions from the readxl package. What happens if we try and use a function from readxl without first loading the package? R will not understand what you mean and return an error. We must always load in package with each R session and before we use a function in a script. This is why we load in packages that we need at the top of every R script - so they’re run first. 5.2 Reading Data We’re ready to use the readxl package. What function can we use from this package to load in our dataset? Remember the help() function where we can find our more information on functions? We can use ??readxl in the R console to find out more information on functions within this package. ??readxl The ?? function runs a search on every function/package we have in R and looks for functions/packages containing readxl. Look for examples that begin with readxl::. This notation is used to inform us of packages and functions, i.e. package::function. Technically speaking, we don’t have to load in a package if we use this notation…but it’s a lot easier to just load in the package than to code every function as package::function. The notation of package::function is primarily used by certain software developers. For our purposes, loading in a package at the top of the script is perfectly acceptable and recommended. Remember, our goal is just to tell R where to find a function so we can use it. Now that we have searched, we can see a line that reads as: readxl::read_excel Read xls and xlsx files. We will use this function, read_excel, to read our amazon_bestsellers.xlxs. What arguments does the read_excelfunction take? We can use our help() function to find out. help(read_excel) A shortcut for the help function is a single ? and is used like so… ?read_excel There are many arguments we can tinker with here if we needed to, but we only need to be concerned with the path argument that defines the “Path to the xls/xlsx file”. 5.3 Paths A path is a series of folder names that directs the computer to the location of a file. For example, if we download a file called amazon_bestsellers.xlsx, it is likely residing in our downloads folder. Our job is to find the path to that file. It might look like /Users/your_name/Downloads/amazon_bestsellers.xlsx on Mac or C:\\your_name\\Downloads\\amazon_bestsellers.xlsx, but is there a way to check for it exactly? Let’s introduce the getwd(), or get working directory, function. getwd() My current directory (aka path) is /Users/james. This is where the “Home” direcoty is located in the files pane of our bottom right hand quadrant. Thus, in order for me to navigate to the Downloads folder, I simply need to type &quot;Downloads/amazon_bestsellers.xlsx&quot;. Additionally, if I wanted to, I could change the current path of the working directory with the setwd() function (aka set working directory). setwd(&quot;Downloads&quot;) Now, if I use getwd() again… getwd() I find that my new working directory is /Users/james/Downloads. Thus, my full path to the amazon_bestsellers.xlsx file is /Users/james/Downloads/amazon_bestsellers.xls. 5.3.1 Path Navigation Trick The tab key on our keyboard is a shortcut key for autocompletion. We can hit the tab key within a set of quotes &quot;&quot; and a visualization of the files and folders of the current working directory will appear. From this point, we can actually click our way to a file and R Studio will automatically fill out the file path to the file for us. This keyboard shortcut can also be used to autocomplete functions, variables/objects, and packages. For example, if I have one really long variable name… onereaaaaaaalllllllyyyyylonnnngggggggvarrriabbblleeeeennnnaaammmeee = &quot;use tab for a shortcut to this&quot; I can start typing the first few letters or so and click the tab key for an autocomplete menu to appear. If the top result is indeed what we want, we can hit the tab key again and the full name of the variable will autocomplete for us. This can also be used to list argument names within a function. The tab key is a great tool and can save us time and headache from mistyping paths or names. 5.3.2 Reading in the File Now that we have the path, we can finally use our read_excel function. # open our amazon bestsellers file using read_excel from the readxl package amzn = read_excel(path = &quot;/Users/james/Downloads/amazon_bestsellers.xlsx&quot;) class(amzn) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; We read in our file succesfully but it was read in as a tibble dataframe by the read_excel function. This is a more advanced form of a dataframe that goes beyond the scope of this course. Let’s convert it to just a standard data frame using our data.frame() function. # overwrite our amzn tibble dataframe and convert it to a standard dataframe amzn = data.frame(amzn) class(amzn) ## [1] &quot;data.frame&quot; Much better. Now let’s print out the first few rows of the amzn dataframe using the head() function to get a feel for the dataset… head(amzn) ## Name ## 1 10-Day Green Smoothie Cleanse ## 2 11/22/63: A Novel ## 3 12 Rules for Life: An Antidote to Chaos ## 4 1984 (Signet Classics) ## 5 5,000 Awesome Facts (About Everything!) (National Geographic Kids) ## 6 A Dance with Dragons (A Song of Ice and Fire) ## Author User.Rating Reviews Price Year Genre ## 1 JJ Smith 4.7 17350 8 2016 Non Fiction ## 2 Stephen King 4.6 2052 22 2011 Fiction ## 3 Jordan B. Peterson 4.7 18979 15 2018 Non Fiction ## 4 George Orwell 4.7 21424 6 2017 Fiction ## 5 National Geographic Kids 4.8 7665 12 2019 Non Fiction ## 6 George R. R. Martin 4.4 12643 11 2011 Fiction Here is a description of what this file contains. Variable Name Definition Name Book Title Author Author of the Book User Rating Amazon book rating as of 10/13/2020 Reviews Total number of book reviews Price Book price as of 10/13/2020 Year Year it was in the top 50 bestsellers on Amazon Genre Book Genre We can actually sort the data by any of the variables we want using the order() function. Let’s order the dataframe based on the User Rating. order(amzn$User Rating, decreasing=TRUE) Error: unexpected symbol in &quot;order(amzn$User Rating&quot;. This is an example of how spaces are bad. R is unable to get around the space between User and Rating in thr variable name. Thus, we will need to rename this variable name to get rid of this. # use indexing to configure which column User Rating is. We know it is the 3rd column amzn[,3] ## [1] 4.7 4.6 4.7 4.7 4.8 4.4 4.7 4.7 4.7 4.6 4.6 4.6 4.6 4.5 4.6 4.5 4.6 4.4 ## [19] 4.5 4.8 4.6 4.6 3.9 4.6 4.3 4.6 4.7 4.2 4.6 4.6 4.8 4.7 4.8 4.8 4.8 4.7 ## [37] 4.7 4.7 4.6 4.5 4.9 4.9 4.8 4.6 4.8 4.5 4.7 4.7 4.7 4.7 4.7 4.7 4.7 4.3 ## [55] 4.8 4.8 4.6 4.6 4.8 4.4 4.6 4.3 4.2 4.8 4.8 4.8 4.8 4.6 4.6 4.5 4.5 4.8 ## [73] 4.8 4.8 4.6 4.6 4.6 4.5 4.6 4.7 4.8 4.9 4.9 4.9 4.9 4.9 4.9 4.9 4.8 4.6 ## [91] 4.5 4.5 4.3 4.5 4.5 4.7 4.7 4.7 4.7 4.7 4.6 4.6 4.7 4.4 4.4 4.5 3.8 3.8 ## [109] 4.5 4.2 4.7 4.7 4.7 4.7 4.7 4.4 4.7 4.4 4.6 4.6 4.6 4.5 4.6 4.8 4.8 4.8 ## [127] 4.8 4.8 4.6 4.6 4.6 4.6 3.6 4.8 4.6 4.0 4.0 4.0 4.6 4.5 4.5 4.5 4.5 4.8 ## [145] 4.8 4.8 4.9 4.9 4.6 4.4 4.8 4.9 4.8 4.9 4.0 4.9 4.9 4.9 4.7 4.8 4.8 4.7 ## [163] 4.7 4.4 4.4 4.8 4.7 4.7 4.7 4.7 4.7 4.3 4.8 4.8 4.9 4.7 4.8 4.6 4.8 4.8 ## [181] 4.3 4.4 4.1 4.6 4.4 4.4 4.8 4.9 4.9 4.9 4.9 4.9 4.9 4.6 4.5 4.6 4.5 4.6 ## [199] 4.7 4.7 4.6 4.6 4.8 4.8 4.5 4.5 4.5 4.9 4.6 4.6 4.6 4.6 4.6 4.5 4.5 4.4 ## [217] 4.8 4.5 4.1 4.9 4.5 4.5 4.2 4.8 4.8 4.8 4.5 4.7 4.8 4.7 4.7 4.7 4.4 4.6 ## [235] 4.6 4.6 4.5 4.5 4.5 4.8 4.8 4.6 4.7 4.6 4.9 4.9 4.9 4.9 4.9 4.9 4.9 4.9 ## [253] 4.9 4.8 4.2 4.6 4.6 4.5 4.3 4.6 4.6 4.6 4.7 4.7 4.8 4.8 4.8 4.8 4.7 4.3 ## [271] 4.3 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.8 4.6 4.6 4.7 4.7 4.6 4.6 ## [289] 4.9 4.9 4.8 4.8 4.6 4.8 4.8 4.7 4.7 4.8 4.1 4.7 4.6 4.6 4.6 4.9 4.0 4.0 ## [307] 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.5 4.6 4.5 4.4 4.4 4.3 4.3 4.7 4.7 4.7 4.7 ## [325] 4.7 4.8 4.8 4.8 4.8 4.8 4.8 4.6 4.6 4.6 4.6 4.7 4.7 4.7 4.7 4.6 4.7 4.7 ## [343] 4.7 4.8 4.2 4.8 4.7 4.6 4.6 4.8 4.8 4.8 4.8 3.3 4.7 4.3 4.3 4.3 4.8 4.4 ## [361] 4.8 4.8 4.8 4.1 4.0 4.7 4.7 4.7 4.7 4.6 4.6 4.6 4.6 4.6 4.6 4.7 4.7 4.7 ## [379] 4.7 4.7 4.7 4.8 4.1 4.1 4.7 4.7 4.7 4.7 4.4 4.4 4.8 4.8 3.9 3.9 4.4 4.4 ## [397] 4.4 4.5 4.7 4.3 4.6 4.8 4.8 4.8 4.8 4.8 4.8 4.7 4.7 4.7 4.8 4.8 4.7 4.7 ## [415] 4.7 4.3 4.3 4.7 4.8 4.8 4.9 4.4 4.4 4.5 4.5 4.5 4.5 4.4 4.8 4.2 4.8 4.9 ## [433] 4.8 4.7 4.5 4.8 4.6 4.8 4.8 4.4 4.4 4.4 4.4 4.4 4.3 4.3 4.8 4.8 4.8 4.5 ## [451] 4.4 4.8 4.8 4.6 4.3 4.3 4.6 4.6 4.8 4.6 4.6 4.6 4.5 4.8 4.6 4.6 4.6 4.7 ## [469] 4.7 4.7 4.4 4.4 4.7 4.7 4.8 4.7 4.9 4.9 4.9 4.9 4.9 4.9 4.9 4.6 4.6 4.6 ## [487] 4.9 4.9 4.9 4.9 4.8 4.8 4.7 4.7 4.6 4.6 4.5 4.5 4.3 4.3 4.6 4.6 4.6 4.6 ## [505] 4.3 4.8 4.8 4.8 4.8 4.8 4.6 4.8 4.5 4.7 4.5 4.8 4.8 4.8 4.8 4.8 4.3 4.9 ## [523] 4.8 4.7 4.8 4.5 4.6 4.7 4.7 4.8 4.4 4.4 4.4 4.8 4.8 4.8 4.6 4.4 4.5 4.2 ## [541] 4.8 4.8 4.8 4.8 4.8 4.9 4.7 4.7 4.7 4.7 # create new column named User_Rating that doesn&#39;t contain spaces and give it the values of the original User Rating variable name amzn[&#39;User_Rating&#39;] = amzn[,3] # print the first few lines of amzn head(amzn) ## Name ## 1 10-Day Green Smoothie Cleanse ## 2 11/22/63: A Novel ## 3 12 Rules for Life: An Antidote to Chaos ## 4 1984 (Signet Classics) ## 5 5,000 Awesome Facts (About Everything!) (National Geographic Kids) ## 6 A Dance with Dragons (A Song of Ice and Fire) ## Author User.Rating Reviews Price Year Genre ## 1 JJ Smith 4.7 17350 8 2016 Non Fiction ## 2 Stephen King 4.6 2052 22 2011 Fiction ## 3 Jordan B. Peterson 4.7 18979 15 2018 Non Fiction ## 4 George Orwell 4.7 21424 6 2017 Fiction ## 5 National Geographic Kids 4.8 7665 12 2019 Non Fiction ## 6 George R. R. Martin 4.4 12643 11 2011 Fiction ## User_Rating ## 1 4.7 ## 2 4.6 ## 3 4.7 ## 4 4.7 ## 5 4.8 ## 6 4.4 Now we have a properly named User_Rating variable and we can delete the faulty variable name from earlier. # remove the 3rd column which is currently User Rating with a space amzn[,3] = NULL Using the code amzn[,3] = NULL, we effectively removed the 3rd column of the amzn dataframe. We need to be very careful not to run this line again as it will remove the 3rd column each time you run it. So, if we were to accidentally run this again, we would remove the Reviews variable within this dataframe which is not what we want to do. # print the variable names of the amzn dataframe names(amzn) ## [1] &quot;Name&quot; &quot;Author&quot; &quot;Reviews&quot; &quot;Price&quot; &quot;Year&quot; ## [6] &quot;Genre&quot; &quot;User_Rating&quot; Now that our names have been fixed, we can look at an order of the highest rated books using the order() function on the User_Rating variable. # print the order of the user ratings order(amzn$User_Rating, decreasing=TRUE) ## [1] 41 42 82 83 84 85 86 87 88 147 148 152 154 156 157 158 175 188 ## [19] 189 190 191 192 193 208 220 245 246 247 248 249 250 251 252 253 289 290 ## [37] 304 421 432 477 478 479 480 481 482 483 487 488 489 490 522 546 5 20 ## [55] 31 33 34 35 43 45 55 56 59 64 65 66 67 72 73 74 81 89 ## [73] 124 125 126 127 128 134 144 145 146 151 153 160 161 166 173 174 177 179 ## [91] 180 187 203 204 217 224 225 226 229 240 241 254 265 266 267 268 282 291 ## [109] 292 294 295 298 326 327 328 329 330 331 344 346 350 351 352 353 359 361 ## [127] 362 363 382 391 392 402 403 404 405 406 407 411 412 419 420 429 431 433 ## [145] 436 438 439 447 448 449 452 453 459 464 475 491 492 506 507 508 509 510 ## [163] 512 516 517 518 519 520 523 525 530 534 535 536 541 542 543 544 545 1 ## [181] 3 4 7 8 9 27 32 36 37 38 47 48 49 50 51 52 53 80 ## [199] 96 97 98 99 100 103 111 112 113 114 115 117 159 162 163 167 168 169 ## [217] 170 171 176 199 200 228 230 231 232 243 263 264 269 285 286 296 297 300 ## [235] 321 322 323 324 325 336 337 338 339 341 342 343 347 355 366 367 368 369 ## [253] 376 377 378 379 380 381 385 386 387 388 399 408 409 410 413 414 415 418 ## [271] 434 468 469 470 473 474 476 493 494 514 524 528 529 547 548 549 550 2 ## [289] 10 11 12 13 15 17 21 22 24 26 29 30 39 44 57 58 61 68 ## [307] 69 75 76 77 79 90 101 102 119 120 121 123 129 130 131 132 135 139 ## [325] 149 178 184 194 196 198 201 202 209 210 211 212 213 234 235 236 242 244 ## [343] 256 257 260 261 262 283 284 287 288 293 301 302 303 315 332 333 334 335 ## [361] 340 348 349 370 371 372 373 374 375 401 437 454 457 458 460 461 462 465 ## [379] 466 467 484 485 486 495 496 501 502 503 504 511 527 537 14 16 19 40 ## [397] 46 70 71 78 91 92 94 95 106 109 122 140 141 142 143 195 197 205 ## [415] 206 207 214 215 218 221 222 227 237 238 239 258 272 273 274 275 276 277 ## [433] 278 279 280 281 314 316 398 424 425 426 427 435 450 463 497 498 513 515 ## [451] 526 539 6 18 60 104 105 116 118 150 164 165 182 185 186 216 233 317 ## [469] 318 360 389 390 395 396 397 422 423 428 440 441 442 443 444 451 471 472 ## [487] 531 532 533 538 25 54 62 93 172 181 259 270 271 319 320 356 357 358 ## [505] 400 416 417 445 446 455 456 499 500 505 521 28 63 110 223 255 345 430 ## [523] 540 183 219 299 364 383 384 136 137 138 155 305 306 307 308 309 310 311 ## [541] 312 313 365 23 393 394 107 108 133 354 This returns the the relative order of each book’s rating (remember, each book has it’s own row). As we can see, the 1st book has the 41st ranked rating. How can we actually re-order our dataframe so that we are sorted from the highest rated to the lowest rated? # reorder our rows based on the user rating column amzn = amzn[order(amzn$User_Rating, decreasing=TRUE),] In the line above, re-order each row for all columns based on the User_Rating column. We use our handy index brackets [] that take a row and column argument to sort each row based on the relative index order of the User_Rating. The column space (aka after the comma that is outside of the order() function) is left blank so we include all columns with this sorting measure. In short, this keeps each row set to the exact same but orders them based on their User Ratings. # print the top few rows head(amzn) ## Name ## 41 Brown Bear, Brown Bear, What Do You See? ## 42 Brown Bear, Brown Bear, What Do You See? ## 82 Dog Man and Cat Kid: From the Creator of Captain Underpants (Dog Man #4) ## 83 Dog Man: A Tale of Two Kitties: From the Creator of Captain Underpants (Dog Man #3) ## 84 Dog Man: Brawl of the Wild: From the Creator of Captain Underpants (Dog Man #6) ## 85 Dog Man: Brawl of the Wild: From the Creator of Captain Underpants (Dog Man #6) ## Author Reviews Price Year Genre User_Rating ## 41 Bill Martin Jr. 14344 5 2017 Fiction 4.9 ## 42 Bill Martin Jr. 14344 5 2019 Fiction 4.9 ## 82 Dav Pilkey 5062 6 2018 Fiction 4.9 ## 83 Dav Pilkey 4786 8 2017 Fiction 4.9 ## 84 Dav Pilkey 7235 4 2018 Fiction 4.9 ## 85 Dav Pilkey 7235 4 2019 Fiction 4.9 # print the last few rows tail(amzn) ## Name ## 393 The Goldfinch: A Novel (Pulitzer Prize for Fiction) ## 394 The Goldfinch: A Novel (Pulitzer Prize for Fiction) ## 107 Fifty Shades of Grey: Book One of the Fifty Shades Trilogy (Fifty Shades of Grey Series) ## 108 Fifty Shades of Grey: Book One of the Fifty Shades Trilogy (Fifty Shades of Grey Series) ## 133 Go Set a Watchman: A Novel ## 354 The Casual Vacancy ## Author Reviews Price Year Genre User_Rating ## 393 Donna Tartt 33844 20 2013 Fiction 3.9 ## 394 Donna Tartt 33844 20 2014 Fiction 3.9 ## 107 E L James 47265 14 2012 Fiction 3.8 ## 108 E L James 47265 14 2013 Fiction 3.8 ## 133 Harper Lee 14982 19 2015 Fiction 3.6 ## 354 J.K. Rowling 9372 12 2012 Fiction 3.3 Our new column name 5.4 Plotting the Data We use plotting as a data visualization method. Plotting the data is a way to tell a story about the data. R has some fantastic plotting packages such as ggplot2, Lattice, and leaflet that are covered in other courses. Today, let’s introduce the R base plotting functions that offer basic, yet very customizable, visualizations. 5.4.1 Base Plotting Base plotting in R comes with an ability to create scatter plots, bar plots, pie charts, histograms, line charts, etc. These are very customizable and offer a solid foundation when transitioning to more advanced plotting packages. While many programmers prefer plotting packages mentioned above, we can still use the base plotting functions from R to create aesthetically pleasing plots. When we are plotting, arguments become very important and these plotting functions can take many arguments. 5.4.2 Histograms Histograms are visual representations of a spread of data. We can use these to quantify where the most frequent values are binned. Let’s create a histogram of the User Ratings. # histogram of the user rating vector from the amzn dataframe hist(x = amzn$User_Rating) The breaks, or bin width, of this histogram is pretty wide. Let’s create finer break areas by listing each rating in a sequence function. # histogram of the user rating from the amzn dataframe with breaks from 3.3 to 5 spaced by 0.1 hist(x = amzn$User_Rating, breaks = seq(from = 3.3, to= 5.0, by=0.1)) A user rating of 4.8 is the most popular rating for this best seller colleciton of books. From here, we can customize the title, color, x label, y label, etc. Unsure of which arguments you can set? Don’t forget about the help function ?hist . # histogram of the user rating from the amzn dataframe with breaks from 3.3 to 5 spaced by 0.1 hist(x = amzn$User_Rating, breaks = seq(from = 3.3, to= 5.0, by=0.1), main = &quot;Amazon Bestseller User Ratings&quot;, col = &quot;lightblue&quot;, xlab = &quot;User Ratings&quot;, ylab = &quot;Number of Occurences&quot;) From the help function we found out the that these arguments dictate the following parameters: Argument Name Definition main Plot Title col Color of the histogram xlab X label name ylab Y label name Each plotting function generally follows the same argument naming scheme. However, they can vary, and this is why it’s important to use the help() function for a plotting function. Additionally, a useful link to bookmark is the R Color Naming Guide. This contains the names of preloaded color names in R. This is where I found lightblue. 5.4.3 Pie Chart Pie charts are useful plots when comparing the number of occurrences for categorical information. For example, one might use a pie chart for wins/losses of a sports team. One of the variables from the Amazon BestSellers dataset is Book Genre. Let’s create a pie chart that shows a pie chart of the genres. First, we’ll need to know which genres are part of the Amazon Book Genre dataset. # use the unique function to print the genres unique(amzn$Genre) ## [1] &quot;Fiction&quot; &quot;Non Fiction&quot; So there are only two broad genres within this dataset. Nonetheless, let’s create a pie chart of these. Let’s count the total number of occurrences for each genre. # count the total number of occurrences for each genre. fic = sum(amzn$Genre == &#39;Fiction&#39;) nonfic = sum(amzn$Genre == &#39;Non Fiction&#39;) Now, we can use these total numbers to create our piechart. # create a vector called slices that contain total number of fiction and nonfiction books slices &lt;- c(fic, nonfic) # create a vector called lbls that contain labels for the respective total number of fiction and nonfiction books lbls &lt;- c(&quot;Fiction&quot;, &quot;Non-Fiction&quot;) # plot using the pie function pie(x = slices, labels = lbls, main=&quot;Pie Chart of Amazon Bestseller Book Genres&quot;) This is a good start. Let’s customize this more by adding colors and percentage values. # create a pct vector that calculates the percentages of each value pct &lt;- round(slices/sum(slices)*100) lbls &lt;- paste(lbls, pct) # add percents to labels lbls ## [1] &quot;Fiction 44&quot; &quot;Non-Fiction 56&quot; Notice here we introduced the paste function that pasted the pct vector values to the end of the lbls values. The paste function and it’s cousin, paste0, are very useful when dealing with character string combinations. This is a heavily used function for many developers. To expand or lbls further, we can add the % sign to the end of each value with the same paste function. lbls &lt;- paste(lbls,&quot;%&quot;,sep=&quot;&quot;) # ad % to labels lbls ## [1] &quot;Fiction 44%&quot; &quot;Non-Fiction 56%&quot; # create color vector that matches a color for each genre cols = c(&quot;dodgerblue4&quot;, &quot;seagreen1&quot;) pie(x = slices,labels = lbls, col=cols,main=&quot;Pie Chart of Amazon Bestseller Book Genres&quot;) 5.4.4 Scatter Plot Another useful plot that can help describe a dataset is a scatter plot. Scatter plots are often used to evaluate a relationship between two variables. In our case, let’s investigate the relationship between number of reviews and user rating. # create scatterplot between number of reviews and user rating plot(x = amzn$Reviews, y = amzn$User_Rating) As we can see, there’s not a distinct correlation between number of reviews and user rating. In other words, more reviews does not necessarily indicate a higher or lower user rating for this dataset. Remember, this dataset only contains the Best Sellers, so our data is limited to the best of the best. We’d likely see a different trend if we had all of the data available. Anyway, even plots that show us no correlation are useful. Let’s spice this up a bit. # create scatterplot between number of reviews and user rating plot(x = amzn$Reviews, y = amzn$User_Rating, xlab = &quot;Total Reviews&quot;, ylab = &quot;Average User Rating&quot;, main=&quot;Amazon Bestsellers 2009-2019&quot;) We can actually go even further here and change our points using the pch argument which is short for plotting character. Then, we can adjust the background color of the points with the bg argument. To go even further, we can also change the size of the point with teh cex argument. # create scatterplot between number of reviews and user rating plot(x = amzn$Reviews, y = amzn$User_Rating, xlab = &quot;Total Reviews&quot;, ylab = &quot;Average User Rating&quot;, main=&quot;Amazon Bestsellers 2009-2019&quot;, pch = 23, bg = &#39;coral&#39;, cex = 2.0, col = &quot;dodgerblue4&quot;) With a few additional arguments, we’re given the ability to customize any plot in R. Altogether, the script we created looks like this. # this script evaluates the Amazon Bestseller Books dataset # James ### begin script ### # load necessary packages library(readxl) # open our amazon bestsellers file using read_excel from the readxl package amzn = read_excel(path = &quot;/Users/james/Downloads/amazon_bestsellers.xlsx&quot;) # DATA MANAGEMENT # overwrite our amzn tibble dataframe and convert it to a standard dataframe amzn = data.frame(amzn) # create new column named User_Rating that doesn&#39;t contain spaces and give it the values of the original User Rating variable name amzn[&#39;User_Rating&#39;] = amzn[,3] # remove the 3rd column which is currently User Rating with a space amzn[,3] = NULL # reorder our rows based on the user rating column amzn = amzn[order(amzn$User_Rating, decreasing=TRUE),] # HISTOGRAM PLOT # histogram of the user rating from the amzn dataframe with breaks from 3.3 to 5 spaced by 0.1 hist(x = amzn$User_Rating, breaks = seq(from = 3.3, to= 5.0, by=0.1), main = &quot;Amazon Bestseller User Ratings&quot;, col = &quot;lightblue&quot;, xlab = &quot;User Ratings&quot;, ylab = &quot;Number of Occurences&quot;) # PIE CHART PLOT # count the total number of occurrences for each genre. fic = sum(amzn$Genre == &#39;Fiction&#39;) nonfic = sum(amzn$Genre == &#39;Non Fiction&#39;) # create a vector called slices that contain total number of fiction and nonfiction books slices &lt;- c(fic, nonfic) # create a vector called lbls that contain labels for the respective total number of fiction and nonfiction books lbls &lt;- c(&quot;Fiction&quot;, &quot;Non-Fiction&quot;) pct &lt;- round(slices/sum(slices)*100) # create a pct vector that calculates the percentages of each value lbls &lt;- paste(lbls, pct) # add percents to labels lbls &lt;- paste(lbls,&quot;%&quot;,sep=&quot;&quot;) # ad % to labels cols = c(&quot;dodgerblue4&quot;, &quot;seagreen1&quot;) # create color vector that matches a color for each genre pie(x = slices,labels = lbls, col=cols,main=&quot;Pie Chart of Amazon Bestseller Book Genres&quot;) # SCATTERPLOT # create scatterplot between number of reviews and user rating plot(x = amzn$Reviews, y = amzn$User_Rating, xlab = &quot;Total Reviews&quot;, ylab = &quot;Average User Rating&quot;, main=&quot;Amazon Bestsellers 2009-2019&quot;, pch = 23, bg = &#39;coral&#39;, cex = 2.0, col = &quot;dodgerblue4&quot;) ``` "],["final-project-world-cup-data.html", "6 Final Project: World Cup Data 6.1 About the Data 6.2 Assessment", " 6 Final Project: World Cup Data In this final comprehension check, we’ll utilize skills we’ve learned over the past 4 days to investigate FIFA World Cup data. The World Cup is the most popular single-sport contest in the world, watched by over 3.5 billion people around the world. Every 4 years, the top 32 countries join to compete in this exciting soccer tournament. The best players on the planet show off their skills and teamwork in an attempt to capture the most sought after prize in sport - the FIFA World Cup Trophy. 6.1 About the Data This dataset contains information regarding the total television audience for the 2010 World cup. Before proceeding, download the fifa_audience_2010.xlxs file from the course datasets folder. Variable Definition country The name of the country audience confederation Each country is a member of a regional soccer organization called a confederation. For example, the United States are part of CONCACAF, which is comprised of North American countries such as Mexico, Canada, Honduras, etc. population_share The relative percentage of world population share tv_audience_share The relative percentage of television audience gdp_weighted_share The relative percentage of gross domestic product (purchasing power) per country 6.2 Assessment The final assessment requires the submission of an R script. It is worth 25 points. Your script will be graded based on the following: Value Grading Metric 15 points Ability to accomplish 5 coding tasks listed below 5 points Methodology and discussion of what’s being attempted in each coding task 5 points Organization of R script (where packages are loaded, where data is read in, commenting, etc.) 6.2.1 Coding Tasks Load appropriate packages, then load in the fifa_audience_2010.xlxs file. Answer the following via coding. Convert this from a tibble dataframe to a standard dataframe. What are the dimensions of the dataframe? What are the column names? What is the class of the country variable? What country is located in the 15th row? What is the class of the 15th country? (just the country itself) Sort the dataframe based on the population_share (from highest share to lowest share). Answer the following via coding. What country is 10th in popoulation share? How many countries have a rounded relative population_share of 0.0%? The cor() function calculates the correlation between two vectors. A perfect match has a correlation of 1 and complete opposites have a correlation value of 0. What is the correlation between gdp_weighted_share and population_share. Does it make sense? Create a scatter plot of gdp_weighted_share and population_share. Include the following Colors, x label, y label, and a pch value of 21 Include the correlation value calculated above in your title Create a bar plot of the population share of the top 10 countries based on this variable. Use the barplot() function. (hint:use help(barplot) if you’re stuck) Include colors, x label, y label, title Create a pie chart of the various confederations. Include percentages and percentage symbol Include unique colors, title, and labels "]]
